#!/usr/bin/env python3
"""
Doxygen MCP Server

A comprehensive Model Context Protocol server that provides full access to Doxygen's 
documentation generation capabilities. This server exposes Doxygen's complete feature 
set through a clean MCP interface, enabling AI assistants to generate, configure, 
and manage documentation for any supported programming language.

Supported Languages:
- Primary: C, C++, Python, PHP
- Extended: Java, C#, JavaScript, Objective-C, Fortran, VHDL
- Additional: Batch, PowerShell, Bash, Perl, Go (through extension mapping)

Key Features:
- Project initialization and configuration management
- Multi-format output generation (HTML, PDF, LaTeX, XML, etc.)
- Advanced diagram generation (UML, call graphs, inheritance diagrams)
- Documentation coverage analysis and validation
- Cross-referencing and link generation
- Custom theme and layout support
"""

import asyncio
import json
import logging
import os
import subprocess
import tempfile
import xml.etree.ElementTree as ET
from pathlib import Path
from typing import Any, Dict, List, Optional, Sequence, Union
import shutil
import re

# MCP server imports
from mcp.server import Server
from mcp.types import (
    Resource,
    Tool,
    TextContent,
    ImageContent,
    EmbeddedResource,
    LoggingLevel
)
from pydantic import BaseModel

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("doxygen-mcp")

class DoxygenConfig(BaseModel):
    """
    @brief Represents a Doxygen configuration with all major options
    
    This class encapsulates all the major configuration options available in Doxygen,
    providing a structured way to manage documentation generation settings. It supports
    multiple programming languages, output formats, and advanced features like diagram
    generation and source browsing.
    
    @details The configuration is designed to be language-agnostic while providing
    specific optimizations for different programming languages. It can generate
    Doxyfile content that is compatible with Doxygen 1.9.0 and later.
    
    @example
    @code{.py}
    config = DoxygenConfig(
        project_name="My API Documentation",
        output_directory="./docs",
        file_patterns=["*.cpp", "*.h"],
        extract_private=False
    )
    doxyfile_content = config.to_doxyfile()
    @endcode
    """
    
    # Project settings
    project_name: str = "My Project"
    project_number: str = ""
    project_brief: str = ""
    project_logo: str = ""
    output_directory: str = "./docs"
    
    # Input settings
    input_paths: List[str] = ["."]
    file_patterns: List[str] = ["*.c", "*.cpp", "*.h", "*.hpp", "*.py", "*.php"]
    recursive: bool = True
    exclude_patterns: List[str] = []
    
    # Language optimization
    optimize_output_for_c: bool = False
    optimize_output_java: bool = False
    optimize_for_fortran: bool = False
    optimize_output_vhdl: bool = False
    
    # Output formats
    generate_html: bool = True
    generate_latex: bool = False
    generate_rtf: bool = False
    generate_man: bool = False
    generate_xml: bool = False
    generate_docbook: bool = False
    
    # Documentation extraction
    extract_all: bool = True
    extract_private: bool = False
    extract_static: bool = True
    extract_local_classes: bool = True
    
    # Diagram generation
    have_dot: bool = True
    class_graph: bool = True
    collaboration_graph: bool = True
    call_graph: bool = False
    caller_graph: bool = False
    include_graph: bool = True
    included_by_graph: bool = True
    
    # Advanced features
    source_browser: bool = True
    inline_sources: bool = False
    strip_code_comments: bool = True
    referenced_by_relation: bool = True
    references_relation: bool = True
    
    def to_doxyfile(self) -> str:
        """
        @brief Convert configuration to Doxyfile format
        @return String containing complete Doxyfile configuration
        
        @details Generates a complete Doxyfile configuration string that can be
        written to disk and used with the doxygen command-line tool. The output
        includes all configured options with appropriate YES/NO values and
        proper escaping for file paths and patterns.
        
        @note The generated Doxyfile is compatible with Doxygen 1.9.0+
        """
        lines = [
            f"# Doxyfile generated by Doxygen MCP Server",
            f"",
            f"# Project related configuration options",
            f"PROJECT_NAME           = \"{self.project_name}\"",
            f"PROJECT_NUMBER         = \"{self.project_number}\"",
            f"PROJECT_BRIEF          = \"{self.project_brief}\"",
            f"PROJECT_LOGO           = \"{self.project_logo}\"",
            f"OUTPUT_DIRECTORY       = \"{self.output_directory}\"",
            f"",
            f"# Build related configuration options",
            f"EXTRACT_ALL            = {'YES' if self.extract_all else 'NO'}",
            f"EXTRACT_PRIVATE        = {'YES' if self.extract_private else 'NO'}",
            f"EXTRACT_STATIC         = {'YES' if self.extract_static else 'NO'}",
            f"EXTRACT_LOCAL_CLASSES  = {'YES' if self.extract_local_classes else 'NO'}",
            f"",
            f"# Input related configuration options",
            f"INPUT                  = {' '.join(self.input_paths)}",
            f"FILE_PATTERNS          = {' '.join(self.file_patterns)}",
            f"RECURSIVE              = {'YES' if self.recursive else 'NO'}",
        ]
        
        if self.exclude_patterns:
            lines.append(f"EXCLUDE_PATTERNS       = {' '.join(self.exclude_patterns)}")
        
        lines.extend([
            f"",
            f"# Language optimization",
            f"OPTIMIZE_OUTPUT_FOR_C  = {'YES' if self.optimize_output_for_c else 'NO'}",
            f"OPTIMIZE_OUTPUT_JAVA   = {'YES' if self.optimize_output_java else 'NO'}",
            f"OPTIMIZE_FOR_FORTRAN   = {'YES' if self.optimize_for_fortran else 'NO'}",
            f"OPTIMIZE_OUTPUT_VHDL   = {'YES' if self.optimize_output_vhdl else 'NO'}",
            f"",
            f"# Output format configuration",
            f"GENERATE_HTML          = {'YES' if self.generate_html else 'NO'}",
            f"GENERATE_LATEX         = {'YES' if self.generate_latex else 'NO'}",
            f"GENERATE_RTF           = {'YES' if self.generate_rtf else 'NO'}",
            f"GENERATE_MAN           = {'YES' if self.generate_man else 'NO'}",
            f"GENERATE_XML           = {'YES' if self.generate_xml else 'NO'}",
            f"GENERATE_DOCBOOK       = {'YES' if self.generate_docbook else 'NO'}",
            f"",
            f"# Diagram generation",
            f"HAVE_DOT               = {'YES' if self.have_dot else 'NO'}",
            f"CLASS_GRAPH            = {'YES' if self.class_graph else 'NO'}",
            f"COLLABORATION_GRAPH    = {'YES' if self.collaboration_graph else 'NO'}",
            f"CALL_GRAPH             = {'YES' if self.call_graph else 'NO'}",
            f"CALLER_GRAPH           = {'YES' if self.caller_graph else 'NO'}",
            f"INCLUDE_GRAPH          = {'YES' if self.include_graph else 'NO'}",
            f"INCLUDED_BY_GRAPH      = {'YES' if self.included_by_graph else 'NO'}",
            f"",
            f"# Source browsing",
            f"SOURCE_BROWSER         = {'YES' if self.source_browser else 'NO'}",
            f"INLINE_SOURCES         = {'YES' if self.inline_sources else 'NO'}",
            f"STRIP_CODE_COMMENTS    = {'YES' if self.strip_code_comments else 'NO'}",
            f"REFERENCED_BY_RELATION = {'YES' if self.referenced_by_relation else 'NO'}",
            f"REFERENCES_RELATION    = {'YES' if self.references_relation else 'NO'}",
        ])
        
        return "\n".join(lines)


class DoxygenServer:
    """
    @brief Core Doxygen server implementation for Model Context Protocol
    
    This class implements a comprehensive MCP server that provides full access to
    Doxygen's documentation generation capabilities. It handles project initialization,
    configuration management, documentation generation, and validation.
    
    @details The server exposes Doxygen functionality through a clean MCP interface,
    enabling AI assistants to generate and manage documentation for projects in
    multiple programming languages. It supports advanced features like diagram
    generation, coverage analysis, and multi-format output.
    
    @note All tool methods are async to comply with MCP protocol requirements
    """
    
    def __init__(self):
        self.server = Server("doxygen-mcp")
        self.projects: Dict[str, DoxygenConfig] = {}
        self.setup_handlers()
    
    def setup_handlers(self):
        """
        @brief Set up all MCP tool handlers
        
        @details Registers all available tools with the MCP server framework,
        including project management, documentation generation, validation,
        and utility functions. Each tool is properly configured with input
        schemas and documentation.
        """
        
        # Project Management Tools
        @self.server.list_tools()
        async def handle_list_tools() -> List[Tool]:
            """List all available Doxygen tools"""
            return [
                # Project Management
                Tool(
                    name="create_doxygen_project",
                    description="Initialize a new Doxygen documentation project with configuration",
                    inputSchema={
                        "type": "object",
                        "properties": {
                            "project_name": {"type": "string", "description": "Name of the project"},
                            "project_path": {"type": "string", "description": "Path to the project directory"},
                            "language": {"type": "string", "enum": ["c", "cpp", "python", "php", "java", "csharp", "javascript", "mixed"], "description": "Primary programming language"},
                            "include_subdirs": {"type": "boolean", "default": True, "description": "Scan subdirectories recursively"},
                            "extract_private": {"type": "boolean", "default": False, "description": "Include private members in documentation"}
                        },
                        "required": ["project_name", "project_path"]
                    }
                ),
                
                Tool(
                    name="generate_documentation",
                    description="Generate documentation from source code using Doxygen",
                    inputSchema={
                        "type": "object",
                        "properties": {
                            "project_path": {"type": "string", "description": "Path to the project directory"},
                            "output_format": {"type": "string", "enum": ["html", "latex", "xml", "all"], "default": "html", "description": "Output format"},
                            "clean_output": {"type": "boolean", "default": True, "description": "Clean output directory before generation"},
                            "verbose": {"type": "boolean", "default": False, "description": "Enable verbose output"}
                        },
                        "required": ["project_path"]
                    }
                ),
                
                Tool(
                    name="scan_project",
                    description="Analyze project structure and identify documentation opportunities",
                    inputSchema={
                        "type": "object",
                        "properties": {
                            "project_path": {"type": "string", "description": "Path to scan"},
                            "language_filter": {"type": "array", "items": {"type": "string"}, "description": "File extensions to include"},
                            "exclude_patterns": {"type": "array", "items": {"type": "string"}, "description": "Patterns to exclude from scanning"}
                        },
                        "required": ["project_path"]
                    }
                ),
                
                Tool(
                    name="validate_documentation",
                    description="Check for documentation warnings, missing docs, and coverage analysis",
                    inputSchema={
                        "type": "object",
                        "properties": {
                            "project_path": {"type": "string", "description": "Path to the project directory"},
                            "check_coverage": {"type": "boolean", "default": True, "description": "Analyze documentation coverage"},
                            "warn_undocumented": {"type": "boolean", "default": True, "description": "Report undocumented members"},
                            "output_format": {"type": "string", "enum": ["text", "json"], "default": "text", "description": "Output format for results"}
                        },
                        "required": ["project_path"]
                    }
                ),
                
                Tool(
                    name="create_doxyfile",
                    description="Generate a Doxyfile configuration with specified settings",
                    inputSchema={
                        "type": "object",
                        "properties": {
                            "output_path": {"type": "string", "description": "Where to save the Doxyfile"},
                            "template": {"type": "string", "enum": ["minimal", "standard", "comprehensive"], "default": "standard", "description": "Configuration template"},
                            "project_settings": {"type": "object", "description": "Project-specific settings"},
                            "language_optimizations": {"type": "array", "items": {"type": "string"}, "description": "Languages to optimize for"}
                        },
                        "required": ["output_path"]
                    }
                ),
                
                Tool(
                    name="check_doxygen_install",
                    description="Verify Doxygen installation and capabilities",
                    inputSchema={
                        "type": "object",
                        "properties": {
                            "check_dot": {"type": "boolean", "default": True, "description": "Check for Graphviz dot tool"},
                            "check_latex": {"type": "boolean", "default": True, "description": "Check for LaTeX installation"},
                            "detailed": {"type": "boolean", "default": False, "description": "Provide detailed version information"}
                        }
                    }
                ),
                
                Tool(
                    name="suggest_file_patterns",
                    description="Suggest appropriate file patterns for a project",
                    inputSchema={
                        "type": "object",
                        "properties": {
                            "project_path": {"type": "string", "description": "Path to analyze"},
                            "primary_language": {"type": "string", "description": "Primary programming language"},
                            "include_tests": {"type": "boolean", "default": False, "description": "Include test file patterns"},
                            "include_examples": {"type": "boolean", "default": True, "description": "Include example file patterns"}
                        },
                        "required": ["project_path"]
                    }
                )
            ]
        
        @self.server.call_tool()
        async def handle_call_tool(name: str, arguments: Dict[str, Any]) -> Sequence[TextContent]:
            """Handle tool calls"""
            try:
                if name == "create_doxygen_project":
                    return await self._create_project(arguments)
                elif name == "generate_documentation":
                    return await self._generate_documentation(arguments)
                elif name == "scan_project":
                    return await self._scan_project(arguments)
                elif name == "validate_documentation":
                    return await self._validate_documentation(arguments)
                elif name == "create_doxyfile":
                    return await self._create_doxyfile(arguments)
                elif name == "check_doxygen_install":
                    return await self._check_doxygen_install(arguments)
                elif name == "suggest_file_patterns":
                    return await self._suggest_file_patterns(arguments)
                else:
                    return [TextContent(type="text", text=f"Unknown tool: {name}")]
            except Exception as e:
                logger.error(f"Error calling tool {name}: {str(e)}")
                return [TextContent(type="text", text=f"Error: {str(e)}")]
    
    # Tool Implementation Methods (simplified for MVP)
    
    async def _create_project(self, args: Dict[str, Any]) -> Sequence[TextContent]:
        """
        @brief Create a new Doxygen project with intelligent configuration
        @param args Dictionary containing project parameters
        @return Sequence of TextContent with creation results
        
        @details Creates a new Doxygen project by:
        - Setting up the project directory structure
        - Generating language-specific configuration
        - Creating an optimized Doxyfile
        - Storing project settings for future operations
        
        @note The generated configuration includes language-specific optimizations
        and file patterns appropriate for the specified programming language.
        """
        project_name = args["project_name"]
        project_path = Path(args["project_path"])
        language = args.get("language", "mixed")
        include_subdirs = args.get("include_subdirs", True)
        extract_private = args.get("extract_private", False)
        
        try:
            # Create project directory if it doesn't exist
            project_path.mkdir(parents=True, exist_ok=True)
            
            # Create configuration based on language
            config = DoxygenConfig(
                project_name=project_name,
                output_directory=str(project_path / "docs"),
                input_paths=[str(project_path)],
                recursive=include_subdirs,
                extract_private=extract_private
            )
            
            # Language-specific optimizations
            if language == "c":
                config.optimize_output_for_c = True
                config.file_patterns = ["*.c", "*.h"]
            elif language == "cpp":
                config.file_patterns = ["*.cpp", "*.hpp", "*.cc", "*.hh", "*.cxx", "*.hxx"]
            elif language == "python":
                config.optimize_output_java = True  # Python uses Java-style optimization
                config.file_patterns = ["*.py"]
            elif language == "php":
                config.file_patterns = ["*.php", "*.php3", "*.inc"]
            elif language == "java":
                config.optimize_output_java = True
                config.file_patterns = ["*.java"]
            elif language == "csharp":
                config.file_patterns = ["*.cs"]
            elif language == "javascript":
                config.file_patterns = ["*.js", "*.jsx", "*.ts", "*.tsx"]
            
            # Save configuration
            doxyfile_path = project_path / "Doxyfile"
            with open(doxyfile_path, 'w', encoding='utf-8') as f:
                f.write(config.to_doxyfile())
            
            # Store project configuration
            self.projects[str(project_path)] = config
            
            result = f"""‚úÖ Doxygen project '{project_name}' created successfully!

üìÅ Project Path: {project_path}
üîß Language: {language}
üìÑ Configuration: {doxyfile_path}

Configuration Summary:
- Output Directory: {config.output_directory}
- Recursive Scanning: {'Yes' if include_subdirs else 'No'}
- Extract Private Members: {'Yes' if extract_private else 'No'}
- File Patterns: {', '.join(config.file_patterns)}

Next Steps:
1. Review and customize the Doxyfile if needed
2. Add documentation comments to your source code
3. Run 'generate_documentation' to create docs

The project is ready for documentation generation!"""
            
            return [TextContent(type="text", text=result)]
            
        except Exception as e:
            return [TextContent(type="text", text=f"‚ùå Failed to create project: {str(e)}")]
    
    async def _generate_documentation(self, args: Dict[str, Any]) -> Sequence[TextContent]:
        """Generate documentation using Doxygen"""
        project_path = Path(args["project_path"])
        output_format = args.get("output_format", "html")
        clean_output = args.get("clean_output", True)
        verbose = args.get("verbose", False)
        
        doxyfile_path = project_path / "Doxyfile"
        if not doxyfile_path.exists():
            return [TextContent(type="text", text="‚ùå No Doxyfile found. Create a project first using 'create_doxygen_project'.")]
        
        try:
            # Check if doxygen is available
            result = subprocess.run(["doxygen", "--version"], capture_output=True, text=True)
            if result.returncode != 0:
                return [TextContent(type="text", text="‚ùå Doxygen not found. Please install Doxygen first.")]
            
            doxygen_version = result.stdout.strip()
            
            # Run Doxygen
            cmd = ["doxygen", str(doxyfile_path)]
            result = subprocess.run(
                cmd, 
                cwd=project_path, 
                capture_output=True, 
                text=True
            )
            
            if result.returncode == 0:
                # Parse output for statistics
                output_lines = result.stderr.split('\n')
                warnings = [line for line in output_lines if 'warning' in line.lower()]
                
                result_text = f"""‚úÖ Documentation generated successfully!

üîß Doxygen Version: {doxygen_version}
üìÅ Project: {project_path}
üìä Warnings: {len(warnings)}

Generated Files:
üìÑ HTML: {project_path / 'docs' / 'html' / 'index.html'}

"""
                
                if warnings and verbose:
                    result_text += f"\n‚ö†Ô∏è Warnings:\n" + "\n".join(warnings[:10])
                    if len(warnings) > 10:
                        result_text += f"\n... and {len(warnings) - 10} more warnings"
                
                if not verbose and warnings:
                    result_text += f"\nüí° Use verbose=true to see detailed warnings"
                
                return [TextContent(type="text", text=result_text)]
            else:
                error_output = result.stderr or result.stdout
                return [TextContent(type="text", text=f"‚ùå Documentation generation failed:\n{error_output}")]
                
        except Exception as e:
            return [TextContent(type="text", text=f"‚ùå Error generating documentation: {str(e)}")]
    
    async def _scan_project(self, args: Dict[str, Any]) -> Sequence[TextContent]:
        """Scan project structure and identify files"""
        project_path = Path(args["project_path"])
        
        if not project_path.exists():
            return [TextContent(type="text", text=f"‚ùå Project path does not exist: {project_path}")]
        
        try:
            # Count files by extension
            extensions = {}
            total_files = 0
            
            for file_path in project_path.rglob("*"):
                if file_path.is_file():
                    ext = file_path.suffix.lower()
                    if ext:
                        extensions[ext] = extensions.get(ext, 0) + 1
                        total_files += 1
            
            # Sort by frequency
            sorted_extensions = sorted(extensions.items(), key=lambda x: x[1], reverse=True)
            
            result_text = f"""üìÅ Project Scan Results for: {project_path}
üìä Total Files Found: {total_files}

üìã Files by Type:
"""
            
            for ext, count in sorted_extensions[:15]:  # Show top 15 extensions
                result_text += f"  üìÑ {ext}: {count} files\n"
            
            return [TextContent(type="text", text=result_text)]
            
        except Exception as e:
            return [TextContent(type="text", text=f"‚ùå Error scanning project: {str(e)}")]
    
    # Simplified implementations for other methods
    async def _validate_documentation(self, args: Dict[str, Any]) -> Sequence[TextContent]:
        return [TextContent(type="text", text="üöß Documentation validation coming soon!")]
    
    async def _create_doxyfile(self, args: Dict[str, Any]) -> Sequence[TextContent]:
        return [TextContent(type="text", text="üöß Create Doxyfile functionality coming soon!")]
    
    async def _check_doxygen_install(self, args: Dict[str, Any]) -> Sequence[TextContent]:
        try:
            result = subprocess.run(["doxygen", "--version"], capture_output=True, text=True)
            if result.returncode == 0:
                version = result.stdout.strip()
                return [TextContent(type="text", text=f"‚úÖ Doxygen {version} is installed and working!")]
            else:
                return [TextContent(type="text", text="‚ùå Doxygen is not working properly")]
        except FileNotFoundError:
            return [TextContent(type="text", text="‚ùå Doxygen is not installed")]
    
    async def _suggest_file_patterns(self, args: Dict[str, Any]) -> Sequence[TextContent]:
        """
        @brief Suggest appropriate file patterns for a project
        @param args Dictionary containing analysis parameters
        @return Sequence of TextContent with pattern suggestions
        
        @details Analyzes the project directory to identify file types and
        suggests appropriate FILE_PATTERNS for Doxygen configuration based on
        the actual files found in the project.
        """
        project_path = Path(args["project_path"])
        primary_language = args.get("primary_language", "")
        include_tests = args.get("include_tests", False)
        include_examples = args.get("include_examples", True)
        
        if not project_path.exists():
            return [TextContent(type="text", text=f"‚ùå Project path does not exist: {project_path}")]
        
        try:
            # Analyze actual files in the project
            extensions = {}
            for file_path in project_path.rglob("*"):
                if file_path.is_file():
                    ext = file_path.suffix.lower()
                    if ext:
                        extensions[ext] = extensions.get(ext, 0) + 1
            
            # Language-specific pattern suggestions
            language_patterns = {
                "c": ["*.c", "*.h"],
                "cpp": ["*.cpp", "*.cxx", "*.cc", "*.C", "*.hpp", "*.hxx", "*.hh", "*.H"],
                "python": ["*.py", "*.pyx", "*.pyi"],
                "java": ["*.java"],
                "php": ["*.php", "*.php3", "*.inc"],
                "javascript": ["*.js", "*.jsx", "*.ts", "*.tsx"],
                "csharp": ["*.cs"],
                "go": ["*.go"],
                "rust": ["*.rs"]
            }
            
            # Build suggestions based on found files and language
            suggested_patterns = []
            
            if primary_language.lower() in language_patterns:
                suggested_patterns.extend(language_patterns[primary_language.lower()])
            
            # Add patterns based on actual files found
            common_source_extensions = {
                ".c", ".cpp", ".cxx", ".cc", ".h", ".hpp", ".hxx", ".hh",
                ".py", ".java", ".php", ".js", ".jsx", ".ts", ".tsx",
                ".cs", ".go", ".rs", ".rb", ".pl", ".sh"
            }
            
            for ext in extensions:
                if ext in common_source_extensions:
                    pattern = f"*{ext}"
                    if pattern not in suggested_patterns:
                        suggested_patterns.append(pattern)
            
            # Optional patterns
            optional_patterns = []
            if include_examples and any(ext in [".md", ".txt", ".rst"] for ext in extensions):
                optional_patterns.extend(["*.md", "*.txt", "*.rst"])
            
            if include_tests:
                optional_patterns.extend(["test_*.py", "*_test.cpp", "Test*.java"])
            
            result_text = f"""üìã File Pattern Suggestions for: {project_path}

üéØ Recommended Patterns:
{chr(10).join(f"  üìÑ {pattern}" for pattern in suggested_patterns)}

üìä Found Extensions:
{chr(10).join(f"  {ext}: {count} files" for ext, count in sorted(extensions.items(), key=lambda x: x[1], reverse=True)[:10])}
"""
            
            if optional_patterns:
                result_text += f"\nüîß Optional Patterns:\n{chr(10).join(f'  üìÑ {pattern}' for pattern in optional_patterns)}"
            
            result_text += f"\n\nüí° Add these patterns to your Doxyfile:\nFILE_PATTERNS = {' '.join(suggested_patterns)}"
            
            return [TextContent(type="text", text=result_text)]
            
        except Exception as e:
            return [TextContent(type="text", text=f"‚ùå Error analyzing patterns: {str(e)}")]


async def main():
    """
    @brief Main entry point for the Doxygen MCP server
    
    @details Initializes the Doxygen MCP server and runs it using stdio transport.
    This function sets up the server instance, configures the MCP communication
    channels, and starts the main server loop.
    
    @note This function runs indefinitely until the MCP client disconnects
    """
    doxygen_server = DoxygenServer()
    
    # Run the server using stdio
    from mcp.server.stdio import stdio_server
    
    async with stdio_server() as (read_stream, write_stream):
        await doxygen_server.server.run(
            read_stream,
            write_stream,
            doxygen_server.server.create_initialization_options()
        )

if __name__ == "__main__":
    asyncio.run(main())
